# cluster wwwphp
upstream wwwphp {
    server 127.0.0.1:8080;
}

# cluster redis
upstream redis {
    server 127.0.0.1:6379;
    # a pool with at most 1024 connections
    # and do not distinguish the servers:
    keepalive 1024 single;
}

# proxy server
server {
    listen 80;
    server_name localhost;
    charset      utf-8;
    access_log   /var/log/nginx/localhost/proxy-redis_access.log;
    #error_log    /var/log/nginx/localhost/proxy-redis_error.log debug;
    error_log    /var/log/nginx/localhost/proxy-redis_error.log ;

    # headers_more
    more_set_headers 'X-Proxy-Server: David RedisProxyServer';


    location / {
        default_type text/html;

        ssi on;

        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_redirect off;

        # toutes les requetes POST vont sur wwwphp
#        if ($request_method = POST) {
#            proxy_pass http://wwwphp; 
#            break;
#        }

        # on regarde si l'url est cachee dans redis (cle = url, valeur = body)
        set_unescape_uri $key $request_uri; # this requires the ngx_set_misc module

        # gestion du cache
        content_by_lua '
            -- si ce n\'est pas GET ou HEAD, on ne regarde pas dans redis
            ngx.log(ngx.NOTICE, "[LUA] Is the request cacheable ?")
            if (ngx.var.request_method ~= "GET" and ngx.var.request_method ~= "HEAD") then
                ngx.log(ngx.NOTICE, "[LUA] NO, skipping uncacheable request method: ", ngx.var.request_method)
                ngx.exit(ngx.HTTP_NOT_FOUND)
            else
                ngx.log(ngx.NOTICE, "[LUA] YES, cacheable request found: ", ngx.var.host, ngx.var.uri)
            end
            
            -- parser object that will receive redis responses and parse them into lua objects
            local parser = require "redis.parser"

            ngx.log(ngx.NOTICE, "[LUA] Is the response in the redis cache ?")
            local redis_get_response = ngx.location.capture("/redis_get", {args = {k = ngx.var.key}})
            local res, typ = parser.parse_reply(redis_get_response.body)

            if (typ == parser.BULK_REPLY and not(res == nil) and (#res > 0)) then
                ngx.log(ngx.NOTICE, "[LUA] YES, cache HIT on cache key: ", ngx.var.key, ", content length: ", #res)
                ngx.print(res)
                ngx.exit(ngx.OK)
            else
                -- la page n\'est pas dans le cache, on la demande au backend
                ngx.log(ngx.NOTICE, "[LUA] NO, cache MISS on cache key: ", ngx.var.key)
                local fallback_response = ngx.location.capture("/fallback"..ngx.var.key)
--ngx.print("retour ", fallback_response.status)
--ngx.exit(ngx.HTTP_OK)
                if fallback_response.status == ngx.HTTP_OK then
                    -- on cache la reponse
                    ngx.req.set_header("X-Cachetime", ngx.http_time(ngx.time()))
                    ngx.log(ngx.NOTICE, "[LUA] got response from /fallback, uri ",ngx.var.key," must be cached")
                    -- on utilise le parser redis pour construire la requete sinon ca ne fonctionne pas a cause des retours charriots dans le html
                    local setex_query = {"SETEX", ngx.var.key, "20", fallback_response.body}
                    local setex_response = ngx.location.capture("/redis_post", { method = ngx.HTTP_POST, body = parser.build_query(setex_query)})
--ngx.print("retour /redis_post : ", setex_response.body)
--ngx.exit(ngx.HTTP_OK)
                    local res, typ = parser.parse_reply(setex_response.body)
--ngx.print("retour /redis_post : ", res)
--ngx.exit(ngx.HTTP_OK)
                    
                    -- on retourne le contenu et un code 200
                    ngx.print(fallback_response.body)
                    ngx.exit(ngx.OK)
                end
            end

            -- si on arrive ici, on renvoie un 404
            ngx.log(ngx.NOTICE, "[LUA] on renvoie 404 pour passer au @fallback")
--            ngx.exit(ngx.HTTP_NOT_FOUND)
        ';


#        proxy_intercept_errors  on;
            
        # si le contenu n'est pas dans redis, on renvoie vers @fallback
#        error_page 404 = @fallback;
    }


    # on passe dans cette location uniquement si on n'arrive pas à servir la reqête depuis redis
    location /fallback {
        # on authorise uniquement les redirections internes de passer par /fallback
        internal;

        # on active les logs rewrite dans le error_log en notice level
        rewrite_log on;

        # headers_more
        more_set_headers 'X-Fallback: Yes';

        # rewrite avant de passe la requête au backend
        rewrite ^/fallback/(.*) /$1 break;

        #ssi on;

        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            
        proxy_redirect off;

        # on passe la requete a wwwphp
        proxy_pass http://wwwphp;
    }


    # url interne d'interrogation du cache redis : utilise ?k=... en querystring
    location /redis_get {
        internal;
        set_unescape_uri $k $arg_k;
        redis2_query get $k;

        redis2_connect_timeout 200ms;
        redis2_send_timeout 200ms;
        redis2_read_timeout 200ms;
        redis2_pass redis;

        # si redis est hs ou met trop de temps à répondre, on demande à recevoir une chaine vide de façon à la renvoyer à l'url demandée qui déclenchera le fallback
        error_page 500 501 502 503 504 505 @empty_string;
    }

    # url interne permettant de balancer des requêtes à redis en POST
    location /redis_post {
        internal;
        default_type text/html;

        # we need to read body explicitly here...or $echo_request_body will evaluate to empty ("")
        echo_read_request_body;

#echo "method: $echo_request_method";
#echo "body: $echo_request_body";

        redis2_raw_query "$echo_request_body\r\n";

        redis2_connect_timeout 200ms;
        redis2_send_timeout 200ms;
        redis2_read_timeout 200ms;
        redis2_pass redis;
    }


    # @todo
    # url interne de décache : utilise ?k=... en querystring
    location /redis_uncache {
#        internal;
        set_unescape_uri $k $arg_k;
        redis2_raw_query "ttl $k 1\r\n";

        redis2_connect_timeout 200ms;
        redis2_send_timeout 200ms;
        redis2_read_timeout 200ms;
        redis2_pass redis;

        # si redis est hs ou met trop de temps à répondre, on demande à recevoir une chaine vide de façon à la renvoyer à l'url demandée qui déclenchera le fallback
        error_page 500 501 502 503 504 505 @empty_string;
    }


    # retourne une chaine vide
    location @empty_string {
        internal;
        content_by_lua 'ngx.print("")';
    }


}
