# cluster wwwphp
upstream wwwphp {
    server 127.0.0.1:8080;
}

# cluster redis
upstream redis {
    server 127.0.0.1:6379;
    # a pool with at most 1024 connections
    # and do not distinguish the servers:
    keepalive 1024 single;
}

# proxy server
server {
    listen 80;
    server_name localhost;
    charset      utf-8;
    access_log   /var/log/nginx/localhost/proxy-redis_access.log;
    #error_log    /var/log/nginx/localhost/proxy-redis_error.log debug;
    error_log    /var/log/nginx/localhost/proxy-redis_error.log;

    # headers_more
    more_set_headers 'X-Proxy-Server: David RedisProxyServer';


    location / {
        default_type text/html;

        #ssi on;

        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_redirect off;

        # toutes les requetes POST vont sur wwwphp
#        if ($request_method = POST) {
#            proxy_pass http://wwwphp; 
#            break;
#        }

        #
        # Cache management
        # 

        # catch the uri to used as a redis key (this requires the ngx_set_misc module)
        set_unescape_uri $key $request_uri;

        content_by_lua '
            -- if the method is not GET or HEAD, do not read in redis
            ngx.log(ngx.NOTICE, "[LUA] Is the request cacheable ?")
            if (ngx.var.request_method ~= "GET" and ngx.var.request_method ~= "HEAD") then
                ngx.log(ngx.NOTICE, "[LUA] NO, skipping uncacheable request method: ", ngx.var.request_method)
                ngx.exit(ngx.HTTP_NOT_FOUND)
            else
                ngx.log(ngx.NOTICE, "[LUA] YES, cacheable request found: ", ngx.var.host, ngx.var.uri)
            end
            
            -- parser object that will receive redis responses and parse them into lua objects
            local parser = require "redis.parser"

            ngx.log(ngx.NOTICE, "[LUA] Is the response in the redis cache ?")
            local redis_read_response = ngx.location.capture("/redis_read", {args = {k = ngx.var.key}})
            local res, typ = parser.parse_reply(redis_read_response.body)

            if (typ == parser.BULK_REPLY and not(res == nil) and (#res > 0)) then
                ngx.log(ngx.NOTICE, "[LUA] YES, cache HIT on cache key: ", ngx.var.key, ", content length: ", #res)
                ngx.print(res)
                ngx.exit(ngx.OK)
            else
                -- the content is not in redis, request to the backend
                ngx.log(ngx.NOTICE, "[LUA] NO, cache MISS on cache key: ", ngx.var.key)
                local fallback_response = ngx.location.capture("/fallback"..ngx.var.key)
--ngx.print("retour ", fallback_response.status)
--ngx.exit(ngx.HTTP_OK)
                if fallback_response.status == ngx.HTTP_OK then
                    -- write the response in redis
                    ngx.req.set_header("X-Cachetime", ngx.http_time(ngx.time()))
                    ngx.log(ngx.NOTICE, "[LUA] got response from /fallback, uri ",ngx.var.key," must be cached")
                    -- because of carriage returns in HTML code, we use the redis parser to build the query
                    local setex_query = {"SETEX", ngx.var.key, "20", fallback_response.body}
                    local setex_response = ngx.location.capture("/redis_write", { method = ngx.HTTP_POST, body = parser.build_query(setex_query)})
--ngx.print("retour /redis_write : ", setex_response.body)
--ngx.exit(ngx.HTTP_OK)
                    local res, typ = parser.parse_reply(setex_response.body)
--ngx.print("retour /redis_write : ", res)
--ngx.exit(ngx.HTTP_OK)
                    
                    -- on retourne le contenu et un code 200
                    ngx.print(fallback_response.body)
                    ngx.exit(ngx.OK)
                end
            end

            -- si on arrive ici, on renvoie un 404
            ngx.log(ngx.NOTICE, "[LUA] on renvoie 404")
            ngx.exit(ngx.HTTP_NOT_FOUND)
        ';

    }


    #
    # This location is used to request the backend when the content is not in redis
    #
    location /fallback {
        # only internal redirections (/fallback can not be accessed directly)
        internal;

        # rewrite logs activation in the error_log file with notice level
        rewrite_log on;

        # headers_more
        more_set_headers 'X-Fallback: Yes';

        # rewrite before passing the request to the backend
        rewrite ^/fallback/(.*) /$1 break;

        #ssi on;

        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            
        proxy_redirect off;

        # send request to the backend
        proxy_pass http://wwwphp;
    }


    #
    # This location is used to read in redis
    # using GET method : ?k=<a_key>
    #
    location /redis_read {
        internal;
        set_unescape_uri $k $arg_k;
        redis2_query get $k;

        redis2_connect_timeout 200ms;
        redis2_send_timeout 200ms;
        redis2_read_timeout 200ms;
        redis2_pass redis;

        # if redis does not respond, we request an emty string
        error_page 500 501 502 503 504 505 @empty_string;
    }


    #
    # This location is used to write content in redis
    # using POST method
    #
    location /redis_write {
        internal;
        default_type text/html;

        # we need to read body explicitly here...or $echo_request_body will evaluate to empty ("")
        echo_read_request_body;

#echo "method: $echo_request_method";
#echo "body: $echo_request_body";

        redis2_raw_query "$echo_request_body\r\n";

        redis2_connect_timeout 200ms;
        redis2_send_timeout 200ms;
        redis2_read_timeout 200ms;
        redis2_pass redis;
    }


    # @todo
    # This location is used to delete content in redis
    # using GET methode : ?k=<a_key>
    #
    location /redis_uncache {
#        internal;
        set_unescape_uri $k $arg_k;
        redis2_raw_query "ttl $k 1\r\n";

        redis2_connect_timeout 200ms;
        redis2_send_timeout 200ms;
        redis2_read_timeout 200ms;
        redis2_pass redis;

        # if redis does not respond, we request an emty string
        error_page 500 501 502 503 504 505 @empty_string;
    }


    #
    # This location return an empty string
    #
    location @empty_string {
        internal;
        content_by_lua 'ngx.print("")';
    }


}
